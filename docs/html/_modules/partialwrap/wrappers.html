<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>partialwrap.wrappers &#8212; partialwrap 1.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for partialwrap.wrappers</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Wrappers to partialise functions so that they can be simply called as func(x).</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    from functools import partial</span>
<span class="sd">    if isinstance(func, (str,list)):</span>
<span class="sd">        obj = partial(exe_wrapper, func,</span>
<span class="sd">                      parameterfile, parameterwriter, outputfile, outputreader,</span>
<span class="sd">                      {&#39;shell&#39;:bool, &#39;debug&#39;:bool, &#39;pid&#39;:bool,</span>
<span class="sd">                       &#39;pargs&#39;:list, &#39;pkwargs&#39;:dict, &#39;keepparameterfile&#39;:bool,</span>
<span class="sd">                       &#39;oargs&#39;:list, &#39;okwargs&#39;:dict, &#39;keepoutputfile&#39;:bool})</span>
<span class="sd">    else:</span>
<span class="sd">        obj = partial(function_wrapper, func, arg, kwarg)</span>
<span class="sd">    fx = obj(x)</span>

<span class="sd">`func` can be a Python function or external executable. External executables</span>
<span class="sd">will be passed to `subprocess.run(func)`. `func` can then be a string (e.g.</span>
<span class="sd">&#39;./prog -arg&#39;) if `shell=True` or a list (e.g. [&#39;./prog&#39;, &#39;-arg&#39;]) if</span>
<span class="sd">`shell=False` (default). Programs without arguments, pipes, etc. can simply be</span>
<span class="sd">strings with `shell=True` or `False`.</span>

<span class="sd">This module was written by Matthias Cuntz while at Institut National de</span>
<span class="sd">Recherche pour l&#39;Agriculture, l&#39;Alimentation et l&#39;Environnement (INRAE), Nancy,</span>
<span class="sd">France.</span>

<span class="sd">Copyright (c) 2016-2022 Matthias Cuntz - mc (at) macu (dot) de</span>

<span class="sd">Released under the MIT License; see LICENSE file for details.</span>

<span class="sd">.. moduleauthor:: Matthias Cuntz</span>

<span class="sd">The following wrappers are provided:</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   exe_wrapper</span>
<span class="sd">   exe_mask_wrapper</span>
<span class="sd">   function_wrapper</span>
<span class="sd">   function_mask_wrapper</span>

<span class="sd">History</span>
<span class="sd">    * Written Nov 2016 by Matthias Cuntz (mc (at) macu (dot) de)</span>
<span class="sd">    * Added x0 and mask to wrapper of external programs,</span>
<span class="sd">      Jan 2018, Matthias Cuntz</span>
<span class="sd">    * Added that `pid` is passed to parameterwriter,</span>
<span class="sd">      and check parameterwriter (getargspec) for number or args, Feb 2018,</span>
<span class="sd">      Matthias Cuntz</span>
<span class="sd">    * Removed check of number of parameters of parameterwriter (getargspec) but</span>
<span class="sd">      add separate wrappers for separate parmeterwriters with different number</span>
<span class="sd">      or arguments, Feb 2018, Matthias Cuntz</span>
<span class="sd">    * Added `plotfile` and made docstring sphinx compatible option, Jan 2018,</span>
<span class="sd">      Matthias Cuntz</span>
<span class="sd">    * Changed to Sphinx docstring and numpydoc, Nov 2019, Matthias Cuntz</span>
<span class="sd">    * Remove that `exe_wrappers` support also Python functions. User should use</span>
<span class="sd">      function_wrappers, Nov 2019, Matthias Cuntz</span>
<span class="sd">    * Make one `exe_wrapper`, passing bounds, mask, etc. via kwarg dictionary</span>
<span class="sd">      to parameterwriter; distinguish iterable and array_like parameter types,</span>
<span class="sd">      Jan 2020, Matthias Cuntz</span>
<span class="sd">    * Replaced kwarg.pop mechanism because it removed the keywords from</span>
<span class="sd">      subsequent function calls, Feb 2020, Matthias Cuntz</span>
<span class="sd">    * Change from ValueError to TypeError if function given to exe wrappers,</span>
<span class="sd">      Feb 2020, Matthias Cuntz</span>
<span class="sd">    * Renamed func to function in calling names, objective to output, and</span>
<span class="sd">      renamed module name to wrappers, May 2020, Matthias Cuntz</span>
<span class="sd">    * Add arguments for outputreader, its handling of pid, and the ability to</span>
<span class="sd">      have multiple output files, Jun 2020, Matthias Cuntz</span>
<span class="sd">    * Correct removal of list of parameterfiles and/or outputfiles, Jun 2020,</span>
<span class="sd">      Matthias Cuntz</span>
<span class="sd">    * Added ability to keep produced parameterfiles and outputfiles, Jun 2020,</span>
<span class="sd">      Matthias Cuntz</span>
<span class="sd">    * Pass pid just before keyword arguments to parameterwriter and</span>
<span class="sd">      outputreader, Jun 2020, Matthias Cuntz</span>
<span class="sd">    * Use `exe_wrapper` in `exe_mask_wrapper`, Jun 2020, Matthias Cuntz</span>
<span class="sd">    * Make flake8 compliant, Dec 2020, Matthias Cuntz</span>
<span class="sd">    * Pass exe and pid as list if not shell in exe_wrapper,</span>
<span class="sd">      May 2021, Matthias Cuntz</span>
<span class="sd">    * Change to subprocess.run for Python &gt;= v3.5, Aug 2022, Matthias Cuntz</span>
<span class="sd">    * Added examples and reformatted docstrings, Aug 2022, Matthias Cuntz</span>
<span class="sd">    * Added error function as fallback option in case subprocess exits with</span>
<span class="sd">      error code &gt; 0, Aug 2022, Matthias Cuntz</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">subprocess</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;exe_wrapper&#39;</span><span class="p">,</span> <span class="s1">&#39;exe_mask_wrapper&#39;</span><span class="p">,</span>
           <span class="s1">&#39;function_wrapper&#39;</span><span class="p">,</span> <span class="s1">&#39;function_mask_wrapper&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_tolist</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assure that *arg* is a list, e.g. if string or None are given.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg :</span>
<span class="sd">        argument to make list</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list(arg)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _tolist(&#39;string&#39;)</span>
<span class="sd">    [&#39;string&#39;]</span>
<span class="sd">    &gt;&gt;&gt; _tolist([1,2,3])</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; _tolist(None)</span>
<span class="sd">    [None]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span>


<div class="viewcode-block" id="exe_wrapper"><a class="viewcode-back" href="../../wrappers.html#partialwrap.wrappers.exe_wrapper">[docs]</a><span class="k">def</span> <span class="nf">exe_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                <span class="n">parameterfile</span><span class="p">,</span> <span class="n">parameterwriter</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span> <span class="n">outputreader</span><span class="p">,</span>
                <span class="n">kwarg</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for external programs using a *parameterwriter* and</span>
<span class="sd">    *outputreader* with the interfaces:</span>
<span class="sd">    ``parameterwriter(parameterfile, x, *pargs, **pkwargs)``</span>
<span class="sd">    and</span>
<span class="sd">    ``outputreader(outputfile, *oargs, **okwargs)``</span>
<span class="sd">    or if *pid==True*:</span>
<span class="sd">    ``parameterwriter(parameterfile, x, *pargs, pid=pid, **pkwargs)``</span>
<span class="sd">    and</span>
<span class="sd">    ``outputreader(outputfile, *oargs, pid=pid, **okwargs)``</span>

<span class="sd">    Examples of *parameterwriter* with *pid==True* are</span>
<span class="sd">    :any:`standard_parameter_writer` or :any:`sub_params_ja`.</span>
<span class="sd">    An example of *outputreader* with or without *pid* is</span>
<span class="sd">    :any:`standard_output_reader`.</span>

<span class="sd">    To be used with :any:`functools.partial`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       obj = partial(exe_wrapper, func,</span>
<span class="sd">                     parameterfile, parameterwriter,</span>
<span class="sd">                     outputfile, outputreader,</span>
<span class="sd">                     {&#39;shell&#39;: bool, &#39;debug&#39;: bool, &#39;pid&#39;: bool,</span>
<span class="sd">                      &#39;pargs&#39;: list, &#39;pkwargs&#39;: dict,</span>
<span class="sd">                      &#39;keepparameterfile&#39;: bool,</span>
<span class="sd">                      &#39;oargs&#39;: list, &#39;okwargs&#39;: dict,</span>
<span class="sd">                      &#39;keepoutputfile&#39;: bool})</span>

<span class="sd">    This allows then calling *obj* simply with the parameters *x*:</span>
<span class="sd">    ``fx = obj(x)``</span>

<span class="sd">    which translates to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       parameterwriter(parameterfile, x, *pargs, **pkwargs)</span>
<span class="sd">       err = subprocess.run(func)</span>
<span class="sd">       obj = outputreader(outputfile, *oargs, **okwargs)</span>

<span class="sd">    or if *pid==True* to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       parameterwriter(parameterfile, x, *pargs, pid=pid, **pkwargs)</span>
<span class="sd">       err = subprocess.run(func)</span>
<span class="sd">       obj = outputreader(outputfile, *oargs, pid=pid, **okwargs)</span>

<span class="sd">    Note if *pid==True*, it is assumed that *parameterwriter* produces</span>
<span class="sd">    files in the form `parameterfile + &#39;.&#39; + processid`,</span>
<span class="sd">    which will be removed after the function call.</span>
<span class="sd">    Also files in the form `outputfile + &#39;.&#39; + processid`</span>
<span class="sd">    will be removed automatically.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : string or list of strings</span>
<span class="sd">        External program to launch by :any:`subprocess`</span>
<span class="sd">    parameterfile : string or iterable</span>
<span class="sd">        Filename(s) of parameter file(s)</span>
<span class="sd">    parameterwriter : callable</span>
<span class="sd">        Python function writing the *parameterfile*, called as:</span>
<span class="sd">        ``parameterwriter(parameterfile, x, *pargs, **pkwargs)``</span>

<span class="sd">        or if *pid==True* as:</span>
<span class="sd">        ``parameterwriter(parameterfile, x, *pargs, pid=pid, **pkwargs)``</span>
<span class="sd">    outputfile : string or iterable</span>
<span class="sd">        Filename(s) of file(s) with output values written by the external</span>
<span class="sd">        executable *func*</span>
<span class="sd">    outputreader : callable</span>
<span class="sd">        Python function for reading and processing output value(s) from</span>
<span class="sd">        *outputfile*, called as:</span>
<span class="sd">        ``outputreader(ouputfile, x, *oargs, **okwargs)``</span>

<span class="sd">        or if *pid==True* as:</span>
<span class="sd">        ``outputreader(ouputfile, x, *oargs, pid=pid, **okwargs)``</span>
<span class="sd">    kwarg : dict</span>
<span class="sd">        Dictionary with keyword arguments for `exe_wrapper`. Possible</span>
<span class="sd">        arguments are:</span>

<span class="sd">        * ``shell`` (bool)</span>
<span class="sd">          If True, :any:`subprocess` opens shell for external executable</span>
<span class="sd">        * ``debug`` (bool)</span>
<span class="sd">          If True, model output is displayed while executable is running</span>
<span class="sd">        * ``pid`` (bool)</span>
<span class="sd">          If True, append &#39;.RandomNumber&#39; to *parameterfile* and</span>
<span class="sd">          *outputfile* for parallel calls of *func*</span>
<span class="sd">        * ``pargs`` (iterable)</span>
<span class="sd">          List of arguments of `parameterwriter`.</span>
<span class="sd">        * ``pkwargs`` (dict)</span>
<span class="sd">          Dictionary with keyword arguments of `parameterwriter`.</span>
<span class="sd">        * ``keepparameterfile`` (bool)</span>
<span class="sd">          If True, `parameterfile` produced with `parameterwriter` will</span>
<span class="sd">          not be deleted after function call.</span>
<span class="sd">        * ``oargs`` (iterable)</span>
<span class="sd">          List of arguments of `outputreader`.</span>
<span class="sd">        * ``okwargs`` (dict)</span>
<span class="sd">          Dictionary with keyword arguments of `outputreader`.</span>
<span class="sd">        * ``keepoutputfile`` (bool)</span>
<span class="sd">          If True, `outputfile` produced by `func` will not be deleted</span>
<span class="sd">          after function call.</span>
<span class="sd">        * ``error`` (function)</span>
<span class="sd">          Function to call in case subprocess exists with error code &gt; 0. The</span>
<span class="sd">          function should take one argument, which will be the random number if</span>
<span class="sd">          `pid=True` or *None* otherwise. The return value will be used instead</span>
<span class="sd">          of the result of *outputreader*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Output value calculated by the external executable *func* or via</span>
<span class="sd">        the *outputreader*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Imagine an external program *prog.exe* written in C or Fortan, for example,</span>
<span class="sd">    that reads in two parameters from the file *params.txt* and writes its</span>
<span class="sd">    results to a file *out.txt*. The parameters can be written with</span>
<span class="sd">    `standard_parameter_writer` and read with `standard_output_reader`.</span>

<span class="sd">    Then this external program can be wrapped as:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from partialwrap import exe_wrapper, standard_parameter_writer</span>
<span class="sd">    &gt;&gt;&gt; from partialwrap import standard_output_reader</span>
<span class="sd">    &gt;&gt;&gt; exe = &#39;prog.exe&#39;</span>
<span class="sd">    &gt;&gt;&gt; parameterfile = &#39;params.txt&#39;</span>
<span class="sd">    &gt;&gt;&gt; outputfile = &#39;out.txt&#39;</span>
<span class="sd">    &gt;&gt;&gt; exewrap = partial(exe_wrapper, exe,</span>
<span class="sd">    ...                   parameterfile, standard_parameter_writer,</span>
<span class="sd">    ...                   outputfile, standard_output_reader, {})</span>

<span class="sd">    And is run as:</span>

<span class="sd">    &gt;&gt;&gt; x0 = [0.1, 0.2]</span>
<span class="sd">    &gt;&gt;&gt; res = exewrap(x0)</span>

<span class="sd">    *res* then holds the output of *prog.exe*.</span>

<span class="sd">    Or one can find the minimum of the function in *prog.exe* with the global</span>
<span class="sd">    optimizer Differential Evolution (assuming here that *prog.exe* calculates</span>
<span class="sd">    the Rastrigin function).</span>

<span class="sd">    &gt;&gt;&gt; import scipy.optimize as opt</span>
<span class="sd">    &gt;&gt;&gt; bounds = [(-5.12, 5.12)] * 2</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(exewrap, bounds)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([-7.32336275e-09,  6.00261842e-09])</span>
<span class="sd">    &gt;&gt;&gt; res.fun</span>
<span class="sd">    0.0</span>

<span class="sd">    If *prog.exe* might fail with some parameter combinations from the</span>
<span class="sd">    Differential Evolution algorithm, then one can give a fallback function for</span>
<span class="sd">    this cases that, for example, returns arbitrary large values.</span>

<span class="sd">    &gt;&gt;&gt; def err(x):</span>
<span class="sd">    ...     return np.random.random() * 10000.</span>
<span class="sd">    &gt;&gt;&gt; exewrap = partial(exe_wrapper, exe,</span>
<span class="sd">    ...                   parameterfile, standard_parameter_writer,</span>
<span class="sd">    ...                   outputfile, standard_output_reader,</span>
<span class="sd">    ...                   {&#39;error&#39;: err})</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(exewrap, bounds)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exe_wrapper_v34</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">parameterfile</span><span class="p">,</span> <span class="n">parameterwriter</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span> <span class="n">outputreader</span><span class="p">,</span>
            <span class="n">kwarg</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">shell</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;shell&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;shell&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">debug</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;debug&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">pid</span>     <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pid&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">pargs</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;pargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">pkwargs</span> <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;pkwargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pkwargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">keepparameterfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;keepparameterfile&#39;</span><span class="p">]</span>
                         <span class="k">if</span> <span class="s1">&#39;keepparameterfile&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">oargs</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;oargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;oargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">okwargs</span> <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;okwargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;okwargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">keepoutputfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;keepoutputfile&#39;</span><span class="p">]</span>
                      <span class="k">if</span> <span class="s1">&#39;keepoutputfile&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">errorfunc</span> <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># For multiprocess but not MPI: pid = mp.current_process()._identity[0]</span>
    <span class="c1"># seed uses global variables so all processes will produce the same</span>
    <span class="c1"># random numbers</span>
    <span class="c1"># -&gt; use np.random.RandomState() for each process to have individual</span>
    <span class="c1">#    seeds in each process</span>
    <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
        <span class="n">randst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
        <span class="n">ipid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">randst</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">))</span>
        <span class="n">pipid</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ipid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ipid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pipid</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
            <span class="n">parameterwriter</span><span class="p">(</span><span class="n">parameterfile</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="n">ipid</span><span class="p">,</span> <span class="o">**</span><span class="n">pkwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">shell</span><span class="p">:</span>
                    <span class="n">func1</span> <span class="o">=</span> <span class="n">func</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">ipid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">func1</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">,</span> <span class="n">ipid</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">shell</span><span class="p">:</span>
                    <span class="n">func1</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">ipid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">func1</span> <span class="o">=</span> <span class="n">func</span> <span class="o">+</span> <span class="p">[</span><span class="n">ipid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parameterwriter</span><span class="p">(</span><span class="n">parameterfile</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="o">**</span><span class="n">pkwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shell</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">func1</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func1</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">spkwarg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;stderr&#39;</span><span class="p">:</span> <span class="n">sp</span><span class="o">.</span><span class="n">PIPE</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spkwarg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;capture_output&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="n">shell</span><span class="p">,</span> <span class="o">**</span><span class="n">spkwarg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">outputreader</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span> <span class="o">*</span><span class="n">oargs</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="n">ipid</span><span class="p">,</span> <span class="o">**</span><span class="n">okwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">outputreader</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span> <span class="o">*</span><span class="n">oargs</span><span class="p">,</span> <span class="o">**</span><span class="n">okwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">sp</span><span class="o">.</span><span class="n">CalledProcessError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">errorfunc</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">errorfunc</span><span class="p">(</span><span class="n">ipid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">cmd</span><span class="p">,</span> <span class="s1">&#39;returned with exit code&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">returncode</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stdout was:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stderr was:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Subprocess error&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepparameterfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">_tolist</span><span class="p">(</span><span class="n">parameterfile</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepoutputfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">_tolist</span><span class="p">(</span><span class="n">outputfile</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;func must be string or list of strings for&#39;</span>
                        <span class="s1">&#39; subprocess. Use function_wrapper for Python&#39;</span>
                        <span class="s1">&#39; functions.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="exe_mask_wrapper"><a class="viewcode-back" href="../../wrappers.html#partialwrap.wrappers.exe_mask_wrapper">[docs]</a><span class="k">def</span> <span class="nf">exe_mask_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
                     <span class="n">parameterfile</span><span class="p">,</span> <span class="n">parameterwriter</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span> <span class="n">outputreader</span><span class="p">,</span>
                     <span class="n">kwarg</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Same as `exe_wrapper` incl./excl. parameters with mask.</span>

<span class="sd">    Makes the transformation:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       xx = np.copy(x0)</span>
<span class="sd">       xx[mask] = x</span>

<span class="sd">    and calls `exe_wrapper` with *xx*.</span>

<span class="sd">    See `exe_wrapper` for details.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Imagine an external program *prog.exe* written in C or Fortan, for example,</span>
<span class="sd">    that reads in two parameters from the file *params.txt* and writes its</span>
<span class="sd">    results to a file *out.txt*. The parameters can be written with</span>
<span class="sd">    `standard_parameter_writer` and read with `standard_output_reader`.</span>

<span class="sd">    Then this external program can be wrapped as:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from partialwrap import exe_wrapper, standard_parameter_writer</span>
<span class="sd">    &gt;&gt;&gt; from partialwrap import standard_output_reader</span>
<span class="sd">    &gt;&gt;&gt; exe = &#39;prog.exe&#39;</span>
<span class="sd">    &gt;&gt;&gt; parameterfile = &#39;params.txt&#39;</span>
<span class="sd">    &gt;&gt;&gt; outputfile = &#39;out.txt&#39;</span>
<span class="sd">    &gt;&gt;&gt; exewrap = partial(exe_wrapper, exe,</span>
<span class="sd">    ...                   parameterfile, standard_parameter_writer,</span>
<span class="sd">    ...                   outputfile, standard_output_reader, {})</span>

<span class="sd">    And is run as:</span>

<span class="sd">    &gt;&gt;&gt; x0 = [0.1, 0.2]</span>
<span class="sd">    &gt;&gt;&gt; res = exewrap(x0)</span>

<span class="sd">    *res* then holds the output of *prog.exe*.</span>

<span class="sd">    Or one can find the minimum of the function in *prog.exe* with the global</span>
<span class="sd">    optimizer Differential Evolution (assuming here that *prog.exe* calculates</span>
<span class="sd">    the Rastrigin function).</span>

<span class="sd">    &gt;&gt;&gt; import scipy.optimize as opt</span>
<span class="sd">    &gt;&gt;&gt; bounds = [(-5.12, 5.12)] * 2</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(exewrap, bounds)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([-7.32336275e-09,  6.00261842e-09])</span>
<span class="sd">    &gt;&gt;&gt; res.fun</span>
<span class="sd">    0.0</span>

<span class="sd">    If one wants to fix the second parameter during optimisation, for example</span>
<span class="sd">    because the parameter is insensitive or one knows the parameter very well,</span>
<span class="sd">    then this parameter can be excluded from the optimisation by using</span>
<span class="sd">    `exe_mask_wrapper`, setting the mask to *False*, and providing *initial*</span>
<span class="sd">    values of the parameters.</span>

<span class="sd">    &gt;&gt;&gt; from partialwrap import exe_mask_wrapper</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([True, False])</span>
<span class="sd">    &gt;&gt;&gt; x0 = np.array([1., 0.])</span>
<span class="sd">    &gt;&gt;&gt; exemwrap = partial(exe_mask_wrapper, exe, x0, mask,</span>
<span class="sd">    ...                    parameterfile, standard_parameter_writer,</span>
<span class="sd">    ...                    outputfile, standard_output_reader, {})</span>

<span class="sd">    &gt;&gt;&gt; bounds = [ bb for ii, bb in enumerate(bounds) if mask[ii] ]</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(exemwrap, bounds)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([-7.32336275e-09])</span>
<span class="sd">    &gt;&gt;&gt; res.fun</span>
<span class="sd">    0.0</span>

<span class="sd">    The final output parameters are then:</span>

<span class="sd">    &gt;&gt;&gt; xout = x0.copy()</span>
<span class="sd">    &gt;&gt;&gt; xout[mask] = res.x</span>
<span class="sd">    &gt;&gt;&gt; xout</span>
<span class="sd">    array([-7.32336275e-09,  0.00000000e+00])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">exe_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                       <span class="n">parameterfile</span><span class="p">,</span> <span class="n">parameterwriter</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span>
                       <span class="n">outputreader</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">exe_wrapper_v34</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                    <span class="n">parameterfile</span><span class="p">,</span> <span class="n">parameterwriter</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">,</span> <span class="n">outputreader</span><span class="p">,</span>
                    <span class="n">kwarg</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    exe_wrapper for Python &lt; v3.7 using subprocess.check_call and</span>
<span class="sd">    subprocess.check_output</span>

<span class="sd">    See `exe_wrapper` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shell</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;shell&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;shell&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">debug</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;debug&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">pid</span>     <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;pid&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pid&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">pargs</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;pargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">pkwargs</span> <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;pkwargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pkwargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">keepparameterfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;keepparameterfile&#39;</span><span class="p">]</span>
                         <span class="k">if</span> <span class="s1">&#39;keepparameterfile&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">oargs</span>   <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;oargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;oargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">okwargs</span> <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;okwargs&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;okwargs&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">keepoutputfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;keepoutputfile&#39;</span><span class="p">]</span>
                      <span class="k">if</span> <span class="s1">&#39;keepoutputfile&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">errorfunc</span> <span class="o">=</span> <span class="n">kwarg</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;error&#39;</span> <span class="ow">in</span> <span class="n">kwarg</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># For multiprocess but not MPI: pid = mp.current_process()._identity[0]</span>
    <span class="c1"># seed uses global variables so all processes will produce same random</span>
    <span class="c1"># numbers</span>
    <span class="c1"># -&gt; use np.random.RandomState() for each processes for individual seeds in</span>
    <span class="c1"># each process</span>
    <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
        <span class="n">randst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
        <span class="n">ipid</span>   <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">randst</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">))</span>
        <span class="n">pipid</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ipid</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ipid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pipid</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
            <span class="n">parameterwriter</span><span class="p">(</span><span class="n">parameterfile</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="n">ipid</span><span class="p">,</span> <span class="o">**</span><span class="n">pkwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">shell</span><span class="p">:</span>
                    <span class="n">func1</span> <span class="o">=</span> <span class="n">func</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">ipid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">func1</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">,</span> <span class="n">ipid</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func1</span> <span class="o">=</span> <span class="n">func</span> <span class="o">+</span> <span class="p">[</span><span class="n">ipid</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parameterwriter</span><span class="p">(</span><span class="n">parameterfile</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">pargs</span><span class="p">,</span> <span class="o">**</span><span class="n">pkwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shell</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">func1</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func1</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">check_call</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">,</span>
                                    <span class="n">shell</span><span class="o">=</span><span class="n">shell</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">check_output</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">STDOUT</span><span class="p">,</span>
                                      <span class="n">shell</span><span class="o">=</span><span class="n">shell</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">outputreader</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span> <span class="o">*</span><span class="n">oargs</span><span class="p">,</span> <span class="n">pid</span><span class="o">=</span><span class="n">ipid</span><span class="p">,</span> <span class="o">**</span><span class="n">okwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">outputreader</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span> <span class="o">*</span><span class="n">oargs</span><span class="p">,</span> <span class="o">**</span><span class="n">okwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">sp</span><span class="o">.</span><span class="n">CalledProcessError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">errorfunc</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">errorfunc</span><span class="p">(</span><span class="n">ipid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">cmd</span><span class="p">,</span> <span class="s1">&#39;returned with exit code&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">returncode</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Subprocess error&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepparameterfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">_tolist</span><span class="p">(</span><span class="n">parameterfile</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keepoutputfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">_tolist</span><span class="p">(</span><span class="n">outputfile</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ff</span> <span class="o">+</span> <span class="n">pipid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">estr</span>  <span class="o">=</span> <span class="s1">&#39;func must be string or list of strings for subprocess.&#39;</span>
        <span class="n">estr</span> <span class="o">+=</span> <span class="s1">&#39; Use function_wrapper for Python functions.&#39;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">estr</span><span class="p">)</span>


<span class="c1"># Python function wrappers</span>
<div class="viewcode-block" id="function_wrapper"><a class="viewcode-back" href="../../wrappers.html#partialwrap.wrappers.function_wrapper">[docs]</a><span class="k">def</span> <span class="nf">function_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for Python functions.</span>

<span class="sd">    To be used with partial:</span>
<span class="sd">    ``obj = partial(function_wrapper, func, arg, kwarg)``</span>

<span class="sd">    This allows then calling obj with only the non-masked parameters:</span>
<span class="sd">    ``fx = obj(x)``</span>

<span class="sd">    which translates to:</span>
<span class="sd">    ``fx = func(x, *arg, **kwarg)``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Python function to be called `func(x, *arg, **kwarg)`</span>
<span class="sd">    arg : iterable</span>
<span class="sd">        Arguments passed to *func*</span>
<span class="sd">    kwarg : dictionary</span>
<span class="sd">        Keyword arguments passed to *func*</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Output value calculated by *func*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Having the Python function *rastrigin* with the parameter *a* and</span>
<span class="sd">    the keyword argument *b*.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; def rastrigin(x, a, b=2.*np.pi):</span>
<span class="sd">    ...     return a * x.size + np.sum(x**2 - a * np.cos(b * x))</span>

<span class="sd">    We want to evaluate the 5-dimensional rastrigin function at</span>
<span class="sd">    `[-1, 0, 1, 2, 3]` using the parameters `a=20.`, `b=np.pi`:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from partialwrap import function_wrapper</span>
<span class="sd">    &gt;&gt;&gt; args   = [20.]</span>
<span class="sd">    &gt;&gt;&gt; kwargs = {&#39;b&#39;: 1.*np.pi}</span>
<span class="sd">    &gt;&gt;&gt; rastra = partial(function_wrapper, rastrigin, args, kwargs)</span>
<span class="sd">    &gt;&gt;&gt; x0 = np.array([-1, 0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; res = rastra(x0)</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    135.0</span>

<span class="sd">    Or find its minimum with the global optimizer Differential Evolution,</span>
<span class="sd">    which allows passing arguments such as `args=(20.)` but does not allow</span>
<span class="sd">    passing keyword arguments such `b=np.pi`.</span>

<span class="sd">    &gt;&gt;&gt; import scipy.optimize as opt</span>
<span class="sd">    &gt;&gt;&gt; bounds = [(-5.12, 5.12)] * 5</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(rastra, bounds)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([-7.32336275e-09,  6.00261842e-09,  1.26476721e-09, -1.61965090e-10,</span>
<span class="sd">           -7.35012009e-09])</span>
<span class="sd">    &gt;&gt;&gt; res.fun</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span></div>


<div class="viewcode-block" id="function_mask_wrapper"><a class="viewcode-back" href="../../wrappers.html#partialwrap.wrappers.function_mask_wrapper">[docs]</a><span class="k">def</span> <span class="nf">function_mask_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Python function using a mask.</span>

<span class="sd">    To be used with partial:</span>
<span class="sd">    ``obj = partial(function_mask_wrapper, func, x0, mask, arg, kwarg)``</span>

<span class="sd">    This allows then calling obj with only the non-masked parameters:</span>
<span class="sd">    ``fx = obj(x)``</span>

<span class="sd">    which translates to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       xx = np.copy(x0)</span>
<span class="sd">       xx[mask] = x</span>
<span class="sd">       fx = func(xx, *arg, **kwarg)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Python function to be called `func(x, *arg, **kwarg)`</span>
<span class="sd">    x0 : array_like</span>
<span class="sd">        Fixed values of masked parameters</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        Mask to use *x0* values (`mask[i]=1`) or use new parameters</span>
<span class="sd">        *x* (`ask[i]=0`) in call of the function</span>
<span class="sd">    arg : iterable</span>
<span class="sd">        Arguments passed to *func*</span>
<span class="sd">    kwarg : dictionary</span>
<span class="sd">        Keyword arguments passed to *func*</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Output value calculated by *func*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Having the Python function *rastrigin* with the parameter *a* and</span>
<span class="sd">    the keyword argument *b*.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; def rastrigin(x, a, b=2.*np.pi):</span>
<span class="sd">    ...     return a * x.size + np.sum(x**2 - a * np.cos(b * x))</span>

<span class="sd">    We want to evaluate the 5-dimensional rastrigin function at</span>
<span class="sd">    `[-1, 0, 1, 2, 3]` using the parameters `a=20.`, `b=np.pi`:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from partialwrap import function_wrapper</span>
<span class="sd">    &gt;&gt;&gt; args   = [20.]</span>
<span class="sd">    &gt;&gt;&gt; kwargs = {&#39;b&#39;: 1.*np.pi}</span>
<span class="sd">    &gt;&gt;&gt; rastra = partial(function_wrapper, rastrigin, args, kwargs)</span>
<span class="sd">    &gt;&gt;&gt; x0 = np.array([-1, 0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; res = rastra(x0)</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    135.0</span>

<span class="sd">    Or we want find its minimum with the global optimizer Differential</span>
<span class="sd">    Evolution, which allows passing arguments such as `args=(20.)` but does not</span>
<span class="sd">    allow passing keyword arguments such `b=np.pi`.</span>

<span class="sd">    &gt;&gt;&gt; import scipy.optimize as opt</span>
<span class="sd">    &gt;&gt;&gt; bounds = [(-5.12, 5.12)] * 5</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(rastra, bounds)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([-7.32336275e-09,  6.00261842e-09,  1.26476721e-09, -1.61965090e-10,</span>
<span class="sd">           -7.35012009e-09])</span>
<span class="sd">    &gt;&gt;&gt; res.fun</span>
<span class="sd">    0.0</span>

<span class="sd">    If one wants to fix the second parameter during optimisation, for example</span>
<span class="sd">    because the parameter is insensitive or one knows the parameter very well</span>
<span class="sd">    (very hypothetical in the example of rastrigin), then this parameter can be</span>
<span class="sd">    excluded from the optimisation by using `function_mask_wrapper`, setting</span>
<span class="sd">    the mask to *False*, and providing *initial* values of the parameters.</span>

<span class="sd">    &gt;&gt;&gt; from partialwrap import function_mask_wrapper</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([True, False, True, True, True])</span>
<span class="sd">    &gt;&gt;&gt; x0 = np.array([1., 0., 2., 3., 4.])</span>
<span class="sd">    &gt;&gt;&gt; rastram = partial(function_mask_wrapper, rastrigin, x0, mask,</span>
<span class="sd">    ...                   args, kwargs)</span>

<span class="sd">    &gt;&gt;&gt; bounds = [ bb for ii, bb in enumerate(bounds) if mask[ii] ]</span>
<span class="sd">    &gt;&gt;&gt; res = opt.differential_evolution(rastram, bounds)</span>
<span class="sd">    &gt;&gt;&gt; res.x</span>
<span class="sd">    array([-7.32336275e-09,  1.26476721e-09, -1.61965090e-10, -7.35012009e-09])</span>
<span class="sd">    &gt;&gt;&gt; res.fun</span>
<span class="sd">    0.0</span>

<span class="sd">    The final output parameters are then:</span>

<span class="sd">    &gt;&gt;&gt; xout = x0.copy()</span>
<span class="sd">    &gt;&gt;&gt; xout[mask] = res.x</span>
<span class="sd">    &gt;&gt;&gt; xout</span>
<span class="sd">    array([-7.32336275e-09,  0.00000000e+00,  1.26476721e-09, -1.61965090e-10,</span>
<span class="sd">           -7.35012009e-09])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xx</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../contents.html">partialwrap</a></h1>



<p class="blurb">Wrappers of external executables and Python functions for functools.partial.</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html#quick-usage-guide">Quick usage guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html#requirements">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html#indices-and-tables">Indices and tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">Public API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://github.com/mcuntz/partialwrap">partialwrap @ GitHub</a></li>
    
    <li class="toctree-l1"><a href="https://doi.org/10.5281/zenodo.3893705">partialwrap @ Zenodo</a></li>
    
    <li class="toctree-l1"><a href="https://pypi.org/project/partialwrap">partialwrap @ PyPI</a></li>
    
    <li class="toctree-l1"><a href="https://anaconda.org/conda-forge/partialwrap">partialwrap @ conda-forge</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016-2023, Matthias Cuntz.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>